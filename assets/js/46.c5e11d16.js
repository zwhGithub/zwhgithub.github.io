(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{732:function(t,s,v){"use strict";v.r(s);var _=v(81),e=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"redis之持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis之持久化"}},[t._v("#")]),t._v(" Redis之持久化")]),t._v(" "),s("blockquote",[s("p",[t._v("目前，Redis 的持久化主要有两大机制，即 AOF 日志和 RDB 快照。")])]),t._v(" "),s("h3",{attrs:{id:"aof-日志是如何实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-日志是如何实现的"}},[t._v("#")]),t._v(" AOF 日志是如何实现的")]),t._v(" "),s("p",[t._v("说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志")]),t._v(" "),s("p",[t._v("但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。")]),t._v(" "),s("p",[t._v("除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以"),s("strong",[t._v("不会阻塞当前的写操作")]),t._v("。")]),t._v(" "),s("p",[t._v("不过，AOF 也有两个潜在的风险。")]),t._v(" "),s("p",[t._v("首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。")]),t._v(" "),s("p",[t._v("其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。")]),t._v(" "),s("p",[t._v("仔细分析的话，你就会发现，这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。")]),t._v(" "),s("h3",{attrs:{id:"三种写回策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三种写回策略"}},[t._v("#")]),t._v(" 三种写回策略")]),t._v(" "),s("p",[t._v("AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。")]),t._v(" "),s("ul",[s("li",[t._v("Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；")]),t._v(" "),s("li",[t._v("Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；")]),t._v(" "),s("li",[t._v("No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。")])]),t._v(" "),s("img",{staticStyle:{width:"1000px"},attrs:{src:"/img/redis-aof.jpg"}}),t._v(" "),s("h3",{attrs:{id:"aof-重写会阻塞吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写会阻塞吗"}},[t._v("#")]),t._v(" AOF 重写会阻塞吗")]),t._v(" "),s("p",[t._v("和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。")]),t._v(" "),s("p",[t._v("我把重写的过程总结为“"),s("strong",[t._v("一个拷贝，两处日志")]),t._v("”。")]),t._v(" "),s("p",[t._v("“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。")]),t._v(" "),s("p",[t._v("然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。“两处日志”又是什么呢？因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。")]),t._v(" "),s("p",[t._v("这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。")])])}),[],!1,null,null,null);s.default=e.exports}}]);