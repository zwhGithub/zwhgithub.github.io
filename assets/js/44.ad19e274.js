(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{730:function(s,a,t){"use strict";t.r(a);var e=t(81),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis之-事务multi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis之-事务multi"}},[s._v("#")]),s._v(" Redis之 事务Multi")]),s._v(" "),a("p",[s._v("为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis 也不例外。Redis 的事务使用非常简单，不同于关系数据库，我们无须理解那么多复杂的事务模型，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样来使用 Redis。")]),s._v(" "),a("h2",{attrs:{id:"redis事务的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis事务的使用"}},[s._v("#")]),s._v(" Redis事务的使用")]),s._v(" "),a("p",[s._v("Redis 在形式上看起来也差不多，分别是 multi/exec/discard。multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。")]),s._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" multi\nOK\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" incr books\nQUEUED\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" incr books\nQUEUED\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("exec")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("上面的指令演示了一个完整的事务过程，所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为 Redis 的单线程特性，它不用担心自己在执行队列的时候被其它指令打搅，可以保证他们能得到的「原子性」执行。")]),s._v(" "),a("h2",{attrs:{id:"原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[s._v("#")]),s._v(" 原子性")]),s._v(" "),a("p",[s._v("事务的原子性是指要么事务全部成功，要么全部失败，那么 Redis 事务执行是原子性的么？")]),s._v(" "),a("p",[a("strong",[s._v("Redis 的事务根本不能算「原子性」，而仅仅是满足了事务的「隔离性」，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。")])]),s._v(" "),a("p",[a("strong",[s._v("Redis 事务不支持回滚")]),s._v("，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成")]),s._v(" "),a("h2",{attrs:{id:"discard-丢弃"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#discard-丢弃"}},[s._v("#")]),s._v(" discard(丢弃)")]),s._v(" "),a("p",[s._v("Redis 为事务提供了一个 discard 指令，用于丢弃事务缓存队列中的所有指令，在 exec 执行之前。\ndiscard 之后，队列中的所有指令都没执行，就好像 multi 和 discard 中间的所有指令从未发生过一样。")])])}),[],!1,null,null,null);a.default=r.exports}}]);